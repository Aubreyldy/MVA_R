tTest <- sqrt(n) * (mx) / sqrt(vx)
return(tTest)
}
tr <- function(n,x,nre){
xR <- matrix(sample(x,n*nre,TRUE),ncol = nre*nre)
mxR <- colMeans(xR)
vxR <- (colSums(xR^2) - n*mxR^2) / (n-1)
tR <- sqrt(n) * (mxR-mean(x)) / sqrt(vxR)
return(tR)
}
simulationtype1 <- function(n,alpha,nsim,nre,mu,std,Dist){
set.seed(1)
x <- drawsample(n,nsim,mu,std,Dist)
crit <- qt(1-alpha/2, n-1)
tTest <- tt(n,x)
tR <- tr(n,x,nre)
pvalue <- 2*min(mean(tR <= tTest), mean(tR >= tTest))
pvt <- 2*min(pt(tTest,n-1),1-pt(tTest,n-1))
result <- data.frame(n = n, Dist = Dist, tTest = mean(abs(tTest) > crit),pvt=pvt,
tR = mean(abs(tR) > crit),pvalue=pvalue)
write.table(result, sep = "\t",  eol = "\r\n", row.names = FALSE, col.names = FALSE, quote = FALSE, append = TRUE)
return(result)
}
quality_criteria <- function(alpha,nsim,ahat){
pil <- alpha-(1.96)*sqrt(alpha*(1-alpha))/nsim
piu <- alpha+(1.96)*sqrt(alpha*(1-alpha))/nsim
if(ahat<=piu & ahat>=pil){
print("the procedure is accurate and the test is called conservative")
}else if(ahat>piu){
print("the procedure is unaccurate and the test is called liberal")
}else if(ahat<pil){
print("the procedure is unaccurate and the test is called conservative")
}
}
N <- c(10,15,20)
dist <- c("Normal","Exponential")
alpha <- 0.05
nsim <- 10000
nre <- 10000
mu <- 0
std <- 1
for(j in dist){
for(i in N){
result <- simulationtype1(i, alpha, nsim,nre, mu,std,j)
quality_criteria(alpha, nsim, result[3])
quality_criteria(alpha, nsim, result[4])
}
}
x <- matrix(((rexp(n = n*nsim, rate = 1) - 1) / sqrt(1)), ncol = nsim)
mx <- colMeans(x)
vx <- (colSums(x^2) - n*mx^2) / (n-1)
tTest <- sqrt(n) * (mx) / sqrt(vx)
xR <- matrix(sample(x,n*nre,TRUE),ncol = nre*nre)
mxR <- colMeans(xR)
xR <- matrix(sample(x,n*nre,TRUE),ncol = nre)
mxR <- colMeans(xR)
vxR <- (colSums(xR^2) - n*mxR^2) / (n-1)
tR <- sqrt(n) * (mxR-mean(x)) / sqrt(vxR)
pvalue <- 2*min(mean(tR <= tTest), mean(tR >= tTest))
pvt <- 2*min(pt(tTest,n-1),1-pt(tTest,n-1))
View(x)
x[:,1]
x[,1]
tR <- tr(n,x[,1],nre)
help(rexp)
help(rexp)
x <- matrix(rexp(n = n, rate = 1) - 1) / sqrt(1))
x <- matrix((rexp(n = n, rate = 1) - 1) / sqrt(1))
View(x)
drawsample <- function(n,mu,std,Dist){
if(Dist == "Normal") {
x <- rnorm(n = n, mu, std)
}
if(Dist == "Exponential") {
x <- matrix((rexp(n = n, rate = 1) - 1) / sqrt(1))
}
return(x)
}
tt <- function(n,x){
mx <- mean(x)
vx <- (sum(x^2) - n*mx^2) / (n-1)
tTest <- sqrt(n) * (mx) / sqrt(vx)
return(tTest)
}
tr <- function(n,x,nre){
xR <- matrix(sample(x,n*nre,TRUE),ncol = nre)
mxR <- colMeans(xR)
vxR <- (colSums(xR^2) - n*mxR^2) / (n-1)
tR <- sqrt(n) * (mxR-mean(x)) / sqrt(vxR)
return(tR)
}
simulationtype1 <- function(n,alpha,nsim,nre,mu,std,Dist){
set.seed(1)
x <- drawsample(n,nsim,mu,std,Dist)
crit <- qt(1-alpha/2, n-1)
tTest <- tt(n,x)
tR <- tr(n,x,nre)
pvalue <- 2*min(mean(tR <= tTest), mean(tR >= tTest))
pvt <- 2*min(pt(tTest,n-1),1-pt(tTest,n-1))
result <- data.frame(n = n, Dist = Dist, tTest = mean(abs(tTest) > crit),pvt=pvt,
tR = mean(abs(tR) > crit),pvalue=pvalue)
write.table(result, sep = "\t",  eol = "\r\n", row.names = FALSE, col.names = FALSE, quote = FALSE, append = TRUE)
return(result)
}
quality_criteria <- function(alpha,nsim,ahat){
pil <- alpha-(1.96)*sqrt(alpha*(1-alpha))/nsim
piu <- alpha+(1.96)*sqrt(alpha*(1-alpha))/nsim
if(ahat<=piu & ahat>=pil){
print("the procedure is accurate and the test is called conservative")
}else if(ahat>piu){
print("the procedure is unaccurate and the test is called liberal")
}else if(ahat<pil){
print("the procedure is unaccurate and the test is called conservative")
}
}
quality_criteria <- function(alpha,nsim,ahat){
pil <- alpha-(1.96)*sqrt(alpha*(1-alpha))/nsim
piu <- alpha+(1.96)*sqrt(alpha*(1-alpha))/nsim
if(ahat<=piu & ahat>=pil){
print("the procedure is accurate and the test is called conservative")
}else if(ahat>piu){
print("the procedure is unaccurate and the test is called liberal")
}else if(ahat<pil){
print("the procedure is unaccurate and the test is called conservative")
}
}
N <- c(10,15,20)
dist <- c("Normal","Exponential")
alpha <- 0.05
nsim <- 10000
nre <- 10000
mu <- 0
std <- 1
for(j in dist){
for(i in N){
result <- simulationtype1(i, alpha, nsim,nre, mu,std,j)
quality_criteria(alpha, nsim, result[3])
quality_criteria(alpha, nsim, result[4])
}
}
drawsample <- function(n,mu,std,Dist){
if(Dist == "Normal") {
x <- rnorm(n = n, mu, std)
}
if(Dist == "Exponential") {
x <- matrix((rexp(n = n, rate = 1) - 1) / sqrt(1))
}
return(x)
}
tt <- function(n,x){
mx <- mean(x)
vx <- (sum(x^2) - n*mx^2) / (n-1)
tTest <- sqrt(n) * (mx) / sqrt(vx)
return(tTest)
}
tr <- function(n,x,nre){
xR <- matrix(sample(x,n*nre,TRUE),ncol = nre)
mxR <- colMeans(xR)
vxR <- (colSums(xR^2) - n*mxR^2) / (n-1)
tR <- sqrt(n) * (mxR-mean(x)) / sqrt(vxR)
return(tR)
}
simulationtype1 <- function(n,alpha,nsim,nre,mu,std,Dist){
set.seed(1)
x <- drawsample(n,nsim,mu,std,Dist)
crit <- qt(1-alpha/2, n-1)
tTest <- tt(n,x)
tR <- tr(n,x,nre)
pvalue <- 2*min(mean(tR <= tTest), mean(tR >= tTest))
pvt <- 2*min(pt(tTest,n-1),1-pt(tTest,n-1))
result <- data.frame(n = n, Dist = Dist, tTest = mean(abs(tTest) > crit),pvt=pvt,
tR = mean(abs(tR) > crit),pvalue=pvalue)
write.table(result, sep = "\t",  eol = "\r\n", row.names = FALSE, col.names = FALSE, quote = FALSE, append = TRUE)
return(result)
}
dist <- c("Normal","Exponential")
for(j in dist){
for(i in N){
result <- simulationtype1(i, alpha, nsim,nre, mu,std,j)
quality_criteria(alpha, nsim, result[3])
quality_criteria(alpha, nsim, result[4])
}
}
result <- simulationtype1(i, alpha, nsim,nre, mu,std,j)
result <- simulationtype1(n,alpha,nsim,nre,mu,std,Dist)
result <- simulationtype1(n,alpha,nsim,nre,mu,std,j)
result <- simulationtype1(i,alpha,nsim,nre,mu,std,j)
mysimulation <- function(n,alpha,nsim,nre,mu,std,Dist){
set.seed(1)
x <- drawsample(n,nsim,mu,std,Dist)
crit <- qt(1-alpha/2, n-1)
tTest <- tt(n,x)
tR <- tr(n,x,nre)
pvalue <- 2*min(mean(tR <= tTest), mean(tR >= tTest))
pvt <- 2*min(pt(tTest,n-1),1-pt(tTest,n-1))
result <- data.frame(n = n, Dist = Dist, tTest = mean(abs(tTest) > crit),pvt=pvt,
tR = mean(abs(tR) > crit),pvalue=pvalue)
write.table(result, sep = "\t",  eol = "\r\n", row.names = FALSE, col.names = FALSE, quote = FALSE, append = TRUE)
return(result)
}
result <- mysimulation(i, alpha, nsim, nre, mu, std, j)
x <- drawsample(n,mu,std,Dist)
mysimulation <- function(n,alpha,nsim,nre,mu,std,Dist){
set.seed(1)
x <- drawsample(n,mu,std,Dist)
crit <- qt(1-alpha/2, n-1)
tTest <- tt(n,x)
tR <- tr(n,x,nre)
pvalue <- 2*min(mean(tR <= tTest), mean(tR >= tTest))
pvt <- 2*min(pt(tTest,n-1),1-pt(tTest,n-1))
result <- data.frame(n = n, Dist = Dist, tTest = mean(abs(tTest) > crit),pvt=pvt,
tR = mean(abs(tR) > crit),pvalue=pvalue)
write.table(result, sep = "\t",  eol = "\r\n", row.names = FALSE, col.names = FALSE, quote = FALSE, append = TRUE)
return(result)
}
for(j in dist){
for(i in N){
result <- mysimulation(i, alpha, nsim, nre, mu, std, j)
quality_criteria(alpha, nsim, result[3])
quality_criteria(alpha, nsim, result[4])
}
}
N <- c(10,15,20)
dist <- c("Normal","Exponential")
alpha <- 0.05
nsim <- 1
nre <- 10000
mu <- 0
std <- 1
for(j in dist){
for(i in N){
result <- mysimulation(i, alpha, nsim, nre, mu, std, j)
quality_criteria(alpha, nsim, result[3])
quality_criteria(alpha, nsim, result[4])
}
}
View(result)
tt <- function(n,x){
mx <- colMeans(x)
vx <- (colSums(x^2) - n*mx^2) / (n-1)
tTest <- sqrt(n) * (mx) / sqrt(vx)
return(tTest)
}
simulationtype1 <- function(n,alpha,nsim,nre,mu,std,Dist){
set.seed(1)
x <- drawsample(n,nsim,mu,std,Dist)
crit <- qt(1-alpha/2, n-1)
tTest <- tt(n,x)
#tR <- tr(n,x[,1],nre)
c1 <- quantile(tTest, 0.025)
c2 <- quantile(tTest, 0.975)
#pvalue <- 2*min(mean(tR <= tTest), mean(tR >= tTest))
#pvt <- 2*min(pt(tTest,n-1),1-pt(tTest,n-1))
resampling <- mean(tTest<=c1 | tTest>=c1)
result <- data.frame(n = n, Dist = Dist, tTest = mean(abs(tTest) > crit),
resampling=resampling)
#                       tR = mean(abs(tR) > crit))
write.table(result, sep = "\t",  eol = "\r\n", row.names = FALSE, col.names = FALSE, quote = FALSE, append = TRUE)
return(result)
}
quality_criteria <- function(alpha,nsim,ahat){
pil <- alpha-(1.96)*sqrt(alpha*(1-alpha))/nsim
piu <- alpha+(1.96)*sqrt(alpha*(1-alpha))/nsim
if(ahat<=piu & ahat>=pil){
print("the procedure is accurate and the test is called conservative")
}else if(ahat>piu){
print("the procedure is unaccurate and the test is called liberal")
}else if(ahat<pil){
print("the procedure is unaccurate and the test is called conservative")
}
}
N <- c(10,15,20)
dist <- c("Normal","Exponential")
alpha <- 0.05
nsim <- 10000
nre <- 10000
mu <- 0
std <- 1
for(j in dist){
for(i in N){
result <- simulationtype1(i, alpha, nsim,nre, mu,std,j)
quality_criteria(alpha, nsim, result[3])
quality_criteria(alpha, nsim, result[5])
}
}
View(result)
for(j in dist){
for(i in N){
result <- simulationtype1(i, alpha, nsim,nre, mu,std,j)
quality_criteria(alpha, nsim, result[3])
quality_criteria(alpha, nsim, result[4])
}
}
drawsample <- function(n,nsim,mu,std,Dist){
if(Dist == "Normal") {
x <- matrix(rnorm(n = n*nsim, mu, std), ncol = nsim)
}
if(Dist == "Exponential") {
x <- matrix(((rexp(n = n*nsim, rate = 1) - 1) / sqrt(1)), ncol = nsim)
}
return(x)
}
tt <- function(n,x){
mx <- colMeans(x)
vx <- (colSums(x^2) - n*mx^2) / (n-1)
tTest <- sqrt(n) * (mx) / sqrt(vx)
return(tTest)
}
simulationtype1 <- function(n,alpha,nsim,mu,std,Dist){
set.seed(1)
x <- drawsample(n,nsim,mu,std,Dist)
crit <- qt(1-alpha/2, n-1)
tTest <- tt(n,x)
#tR <- tr(n,x[,1],nre)
c1 <- quantile(tTest, 0.025)
c2 <- quantile(tTest, 0.975)
#pvalue <- 2*min(mean(tR <= tTest), mean(tR >= tTest))
#pvt <- 2*min(pt(tTest,n-1),1-pt(tTest,n-1))
resampling <- mean(tTest<=c1 | tTest>=c1)
result <- data.frame(n = n, Dist = Dist, tTest = mean(abs(tTest) > crit),
resampling=resampling)
#                       tR = mean(abs(tR) > crit))
write.table(result, sep = "\t",  eol = "\r\n", row.names = FALSE, col.names = FALSE, quote = FALSE, append = TRUE)
return(result)
}
quality_criteria <- function(alpha,nsim,ahat){
pil <- alpha-(1.96)*sqrt(alpha*(1-alpha))/nsim
piu <- alpha+(1.96)*sqrt(alpha*(1-alpha))/nsim
if(ahat<=piu & ahat>=pil){
print("the procedure is accurate and the test is called conservative")
}else if(ahat>piu){
print("the procedure is unaccurate and the test is called liberal")
}else if(ahat<pil){
print("the procedure is unaccurate and the test is called conservative")
}
}
for(j in dist){
for(i in N){
result <- simulationtype1(i, alpha, nsim, mu,std,j)
quality_criteria(alpha, nsim, result[3])
quality_criteria(alpha, nsim, result[4])
}
}
c1 <- quantile(tTest, 0.025)
x <- drawsample(n,nsim,mu,std,Dist)
crit <- qt(1-alpha/2, n-1)
tTest <- tt(n,x)
c1 <- quantile(tTest, 0.025)
c2 <- quantile(tTest, 0.975)
mean(tTest<=c1 | tTest>=c1)
c1
c2
x <- drawsample(n,nsim,mu,std,Dist)
crit <- qt(1-alpha/2, n-1)
tTest <- tt(n,x)
c1 <- quantile(tTest, 0.025)
c2 <- quantile(tTest, 0.975)
resampling <- mean(tTest<=c1 | tTest>=c1)
c1
min(tTest)
resampling <- mean((tTest<=c1) | (tTest>=c1))
resampling <- mean((tTest<=c1) | (tTest>=c2))
result <- data.frame(n = n, Dist = Dist, tTest = mean(abs(tTest) > crit),
resampling=resampling)
simulationtype1 <- function(n,alpha,nsim,mu,std,Dist){
set.seed(1)
x <- drawsample(n,nsim,mu,std,Dist)
crit <- qt(1-alpha/2, n-1)
tTest <- tt(n,x)
#tR <- tr(n,x[,1],nre)
c1 <- quantile(tTest, 0.025)
c2 <- quantile(tTest, 0.975)
#pvalue <- 2*min(mean(tR <= tTest), mean(tR >= tTest))
#pvt <- 2*min(pt(tTest,n-1),1-pt(tTest,n-1))
resampling <- mean((tTest<=c1) | (tTest>=c2))
result <- data.frame(n = n, Dist = Dist, tTest = mean(abs(tTest) > crit),
resampling=resampling)
#                       tR = mean(abs(tR) > crit))
write.table(result, sep = "\t",  eol = "\r\n", row.names = FALSE, col.names = FALSE, quote = FALSE, append = TRUE)
return(result)
}
quality_criteria <- function(alpha,nsim,ahat){
pil <- alpha-(1.96)*sqrt(alpha*(1-alpha))/nsim
piu <- alpha+(1.96)*sqrt(alpha*(1-alpha))/nsim
if(ahat<=piu & ahat>=pil){
print("the procedure is accurate and the test is called conservative")
}else if(ahat>piu){
print("the procedure is unaccurate and the test is called liberal")
}else if(ahat<pil){
print("the procedure is unaccurate and the test is called conservative")
}
}
N <- c(10,15,20)
dist <- c("Normal","Exponential")
alpha <- 0.05
nsim <- 10000
nre <- 10000
mu <- 0
std <- 1
for(j in dist){
for(i in N){
result <- simulationtype1(i, alpha, nsim, mu,std,j)
quality_criteria(alpha, nsim, result[3])
quality_criteria(alpha, nsim, result[4])
}
}
tt <- function(n,x){
mx <- colMeans(x)
vx <- (colSums(x^2) - n*mx^2) / (n-1)
tTest <- sqrt(n) * (mx) / sqrt(vx)
return(tTest)
}
tr <- function(n,x,nre){
xR <- matrix(sample(x,n*nre,TRUE),ncol = nre)
mxR <- colMeans(xR)
vxR <- (colSums(xR^2) - n*mxR^2) / (n-1)
tR <- sqrt(n) * (mxR-mean(x)) / sqrt(vxR)
return(tR)
}
simulationtype1 <- function(n,alpha,nsim,nre,mu,std,Dist){
set.seed(1)
x <- drawsample(n,nsim,mu,std,Dist)
crit <- qt(1-alpha/2, n-1)
tTest <- tt(n,x)
tR <- tr(n,x[,1],nre)
#c1 <- quantile(tTest, 0.025)
#c2 <- quantile(tTest, 0.975)
pvalue <- 2*min(mean(tR <= tTest), mean(tR >= tTest))
pvt <- 2*min(pt(tTest,n-1),1-pt(tTest,n-1))
resampling <- mean((tTest<=c1) | (tTest>=c2))
result <- data.frame(n = n, Dist = Dist, tTest = mean(abs(tTest) > crit),
tR = mean(abs(tR) > crit))
#                      resampling=resampling)
write.table(result, sep = "\t",  eol = "\r\n", row.names = FALSE, col.names = FALSE, quote = FALSE, append = TRUE)
return(result)
}
quality_criteria <- function(alpha,nsim,ahat){
pil <- alpha-(1.96)*sqrt(alpha*(1-alpha))/nsim
piu <- alpha+(1.96)*sqrt(alpha*(1-alpha))/nsim
if(ahat<=piu & ahat>=pil){
print("the procedure is accurate and the test is called conservative")
}else if(ahat>piu){
print("the procedure is unaccurate and the test is called liberal")
}else if(ahat<pil){
print("the procedure is unaccurate and the test is called conservative")
}
}
N <- c(10,15,20)
dist <- c("Normal","Exponential")
alpha <- 0.05
nsim <- 10000
nre <- 10000
mu <- 0
std <- 1
for(j in dist){
for(i in N){
result <- simulationtype1(i, alpha, nsim, nre,mu,std,j)
quality_criteria(alpha, nsim, result[3])
quality_criteria(alpha, nsim, result[5])
}
}
for(j in dist){
for(i in N){
result <- simulationtype1(i, alpha, nsim, nre,mu,std,j)
#quality_criteria(alpha, nsim, result[3])
#quality_criteria(alpha, nsim, result[5])
}
}
quality_criteria(alpha, nsim, result[3])
View(result)
simulationtype1 <- function(n,alpha,nsim,nre,mu,std,Dist){
set.seed(1)
x <- drawsample(n,nsim,mu,std,Dist)
crit <- qt(1-alpha/2, n-1)
tTest <- tt(n,x)
tR <- tr(n,x[,1],nre)
#c1 <- quantile(tTest, 0.025)
#c2 <- quantile(tTest, 0.975)
pvalue <- 2*min(mean(tR <= tTest), mean(tR >= tTest))
pvt <- 2*min(pt(tTest,n-1),1-pt(tTest,n-1))
resampling <- mean((tTest<=c1) | (tTest>=c2))
result <- data.frame(n = n, Dist = Dist, tTest = mean(abs(tTest) > crit),pvt=pvt,
tR = mean(abs(tR) > crit),pvalue=pvalue)
#                      resampling=resampling)
write.table(result, sep = "\t",  eol = "\r\n", row.names = FALSE, col.names = FALSE, quote = FALSE, append = TRUE)
return(result)
}
quality_criteria <- function(alpha,nsim,ahat){
pil <- alpha-(1.96)*sqrt(alpha*(1-alpha))/nsim
piu <- alpha+(1.96)*sqrt(alpha*(1-alpha))/nsim
if(ahat<=piu & ahat>=pil){
print("the procedure is accurate and the test is called conservative")
}else if(ahat>piu){
print("the procedure is unaccurate and the test is called liberal")
}else if(ahat<pil){
print("the procedure is unaccurate and the test is called conservative")
}
}
N <- c(10,15,20)
dist <- c("Normal","Exponential")
alpha <- 0.05
nsim <- 10000
nre <- 10000
mu <- 0
std <- 1
for(j in dist){
for(i in N){
result <- simulationtype1(i, alpha, nsim, nre,mu,std,j)
quality_criteria(alpha, nsim, result[3])
quality_criteria(alpha, nsim, result[5])
}
}
